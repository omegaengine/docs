{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u00b6 The OmegaEngine is a general-purpose 3D graphics engine written in C# using the .NET Framework 2.0 and DirectX 9 via SlimDX. The engine is designed to be light-weight (compiled binaries with external libraries < 4MB), modular (use only the parts you need for your project) and gameplay-agnostic (also suitable for visualization projects, etc.). The engine is well-suited for strategy games, space simulations, etc.. It is not designed for use in FPSes, open-world sandboxes, etc.. Features Screenshots Downloads API documentation Code sample \u00b6 Renders a textured sphere: var engine = new Engine (...); var scene = new Scene { Positionables = { Model . Sphere ( engine , XTexture . Get ( engine , \"flag.png\" ))} }; var camera = new TrackCamera (); engine . Views . Add ( new View ( scene , camera ));","title":"Home"},{"location":"#_1","text":"The OmegaEngine is a general-purpose 3D graphics engine written in C# using the .NET Framework 2.0 and DirectX 9 via SlimDX. The engine is designed to be light-weight (compiled binaries with external libraries < 4MB), modular (use only the parts you need for your project) and gameplay-agnostic (also suitable for visualization projects, etc.). The engine is well-suited for strategy games, space simulations, etc.. It is not designed for use in FPSes, open-world sandboxes, etc.. Features Screenshots Downloads API documentation","title":""},{"location":"#code-sample","text":"Renders a textured sphere: var engine = new Engine (...); var scene = new Scene { Positionables = { Model . Sphere ( engine , XTexture . Get ( engine , \"flag.png\" ))} }; var camera = new TrackCamera (); engine . Views . Add ( new View ( scene , camera ));","title":"Code sample"},{"location":"alphaeditor/","text":"AlphaEditor \u00b6 See Screenshots TODO: Tab templates + Undo System","title":"AlphaEditor"},{"location":"alphaeditor/#alphaeditor","text":"See Screenshots TODO: Tab templates + Undo System","title":"AlphaEditor"},{"location":"features/","text":"An overview of the Engine's features: Scene management Multiple viewports 64bit-precision object positioning Terrain rendering (heightmap-based) Shader management DXSAS support Post-screen effects Dynamic shader generation Asset management Virtual filesystem Mod support Effects Water reflections Bloom/Glow maps Particle systems (with WYSIWYG editor ) Skinable GUI toolkit XML file format (with WYSIWYG editor ) Lua scripting Extendable input system (mouse, keyboard, touch) Legacy hardware support (fallback to fixed function pipeline) Benchmarking and error reporting Render embedded in WinForms or standalone","title":"Features"},{"location":"license/","text":"Licenses for individual components: OmegaEngine and AlphaFramework: Mozilla Public License 2.0 Shaders : MIT license , portions NVidia general developer license OmegaGUI: MIT license , portions MS-PL Sample code: MIT license The specific license applicable to each file is stated in its header. External libraries used by the code are placed under various open source licenses. See the source code for details. In layman's terms this means: You can use the engine to build your own game (free or commercial) without having to release your game's source code. You can add new code files to the engine itself without having to release them. If you modify existing code files of engine itself you will have to share those changes. You can modify the GUI and sample code without having to share those changes. You can modify the Common library and use it in other projects without having to release those changes.","title":"License"},{"location":"screenshots/","text":"Screenshots \u00b6 Terrain Sample \u00b6 River \u00b6 Mountains \u00b6 Debug window (Bounding Box visualization enabled) \u00b6 Lua console (with auto-completion) \u00b6 Editor \u00b6 Map editor \u00b6 Particle system editor \u00b6 GUI/Menu editor (with Lua scripting) \u00b6 Entity editor (Fog enabled) \u00b6","title":"Screenshots"},{"location":"screenshots/#screenshots","text":"","title":"Screenshots"},{"location":"screenshots/#terrain-sample","text":"","title":"Terrain Sample"},{"location":"screenshots/#river","text":"","title":"River"},{"location":"screenshots/#mountains","text":"","title":"Mountains"},{"location":"screenshots/#debug-window-bounding-box-visualization-enabled","text":"","title":"Debug window (Bounding Box visualization enabled)"},{"location":"screenshots/#lua-console-with-auto-completion","text":"","title":"Lua console (with auto-completion)"},{"location":"screenshots/#editor","text":"","title":"Editor"},{"location":"screenshots/#map-editor","text":"","title":"Map editor"},{"location":"screenshots/#particle-system-editor","text":"","title":"Particle system editor"},{"location":"screenshots/#guimenu-editor-with-lua-scripting","text":"","title":"GUI/Menu editor (with Lua scripting)"},{"location":"screenshots/#entity-editor-fog-enabled","text":"","title":"Entity editor (Fog enabled)"},{"location":"assets/","text":"Overview \u00b6 An asset is a content file loaded by the engine at runtime. This includes textures, models, sounds, etc.. These files are located using a Virtual File System . Asset files are often referenced many times during an application's runtime. To prevent repeated load delays the engine keeps loaded and parsed content in an in-memory cache that can be flushed, e.g. after switching maps.","title":"Overview"},{"location":"assets/#overview","text":"An asset is a content file loaded by the engine at runtime. This includes textures, models, sounds, etc.. These files are located using a Virtual File System . Asset files are often referenced many times during an application's runtime. To prevent repeated load delays the engine keeps loaded and parsed content in an in-memory cache that can be flushed, e.g. after switching maps.","title":"Overview"},{"location":"assets/mods/","text":"A game modification (mod) is a set of changes based on an existing game used to modify existing gameplay, add additional content or create an entirely new game. The engine supports mods via a virtual file system and modding support in the AlphaEditor.","title":"Mods"},{"location":"assets/vfs/","text":"VFS \u00b6 The Virtual File System (VFS) combines multiple directory structures into a single view of the filesystem used to load assets . Search order: Files in the active mod directory, if any Data archives in the active mod directory, if any Files in the application's base directory Data archives in the application's base directory Base directory \u00b6 The base directory is usually located in the directory of the application EXE and named base . This location can be overridden in the engine configuration. Data archives \u00b6 The data archives provide a a way to combine the entire game content (maps, scripts, models, textures, ...) into a few large files. This simplifies installation and updating and also reduces the likelihood of users accidentally modifying the content. The data archives are normal ZIP archives, optionally using a file extensions different from .zip . They should be stored in uncompressed form to speed up loading processes.","title":"VFS"},{"location":"assets/vfs/#vfs","text":"The Virtual File System (VFS) combines multiple directory structures into a single view of the filesystem used to load assets . Search order: Files in the active mod directory, if any Data archives in the active mod directory, if any Files in the application's base directory Data archives in the application's base directory","title":"VFS"},{"location":"assets/vfs/#base-directory","text":"The base directory is usually located in the directory of the application EXE and named base . This location can be overridden in the engine configuration.","title":"Base directory"},{"location":"assets/vfs/#data-archives","text":"The data archives provide a a way to combine the entire game content (maps, scripts, models, textures, ...) into a few large files. This simplifies installation and updating and also reduces the likelihood of users accidentally modifying the content. The data archives are normal ZIP archives, optionally using a file extensions different from .zip . They should be stored in uncompressed form to speed up loading processes.","title":"Data archives"},{"location":"details/dispose/","text":"All classes in the OmegaEngine namespace implementing the IDisposable interface must be .Dispose() ed manually. Unlike other .NET objects you can not rely on the garbage collection to cleanup left-over resources here. This is because of circular references caused by event hooks as well as the asset management system's caching feature. If you forget a .Dispose() this may trigger an exception (in Debug mode) or a log entry (in Release mode) at a non-deterministic point in time.","title":"Dispose"},{"location":"details/input-system/","text":"","title":"Input system"},{"location":"details/legacy-support/","text":"The engine is optimized for graphics cards supporting Shader Model 2.0b or better. However it automatically falls back to Shader Model 2.0, 1.1 or the fixed function pipeline on older hardware.","title":"Legacy support"},{"location":"details/lost-device/","text":"The engine automatically restores a DirectX device if it is lost due to resolution changes, minimizing a fullscreen application, etc.. To reduce the amount of required manual reloading resources are stored in Pool.Managed whenever possible. When this is not possible: A delegate registered at the engine.DeviceLost event must release the resource using .Dispose() . A delegate registered at the engine.DeviceReset event must reload the resource.","title":"Lost device"},{"location":"scenes/","text":"Overview \u00b6 The engine manages the visible world it renders via Views , which are a combination of a Camera and a Scene, which in turn contain multiple Renderables . See also: Dispose","title":"Overview"},{"location":"scenes/#overview","text":"The engine manages the visible world it renders via Views , which are a combination of a Camera and a Scene, which in turn contain multiple Renderables . See also: Dispose","title":"Overview"},{"location":"scenes/cameras/","text":"","title":"Cameras"},{"location":"scenes/renderables/","text":"","title":"Renderables"},{"location":"scenes/terrain/","text":"The engine is able to render heightmap-based terrains with multiple blended surface textures and pre-calculated self-shadowing. 2D coordinates \u00b6 Coordinate system directed right-downwards (as used in graphics files). The standard orientation is a view along the positive Y axis. This is sometimes referred to as world coordinates in the source code. Positive X axis Width of the terrain Positive Y axis Depth of the terrain 3D coordinates \u00b6 Left-handed coordinate system (as used by DirectX). The standard orientation is a view along the negative Z axis. This is sometimes referred to as engine coordinates in the source code. Positive X axis Width of the terrain Positive Y axis Height of the terrain Negative Z axis Depth of the terrain","title":"Terrain"},{"location":"scenes/terrain/#2d-coordinates","text":"Coordinate system directed right-downwards (as used in graphics files). The standard orientation is a view along the positive Y axis. This is sometimes referred to as world coordinates in the source code. Positive X axis Width of the terrain Positive Y axis Depth of the terrain","title":"2D coordinates"},{"location":"scenes/terrain/#3d-coordinates","text":"Left-handed coordinate system (as used by DirectX). The standard orientation is a view along the negative Z axis. This is sometimes referred to as engine coordinates in the source code. Positive X axis Width of the terrain Positive Y axis Height of the terrain Negative Z axis Depth of the terrain","title":"3D coordinates"},{"location":"scenes/views/","text":"","title":"Views"},{"location":"shaders/","text":"Overview \u00b6 Shaders are small pieces of code executed directly on the graphics card. They govern how vertexes are transformed and how each individual pixel color is calculated. The engine stores shaders in the High Level Shader Format (HLSL) and supports the DirectX Standard Annotations and Semantics . It can dynamically generate shaders at runtime and apply pixel shaders to the entire scene. The HLSL code is stored in .fx files in the Shader subdirectory of the Engine's source directory. They are compiled to .fxo files via a post-build script. Each HLSL file usually has a corresponding C# class in the OmegaEngine.Graphics.Shaders namespace.","title":"Overview"},{"location":"shaders/#overview","text":"Shaders are small pieces of code executed directly on the graphics card. They govern how vertexes are transformed and how each individual pixel color is calculated. The engine stores shaders in the High Level Shader Format (HLSL) and supports the DirectX Standard Annotations and Semantics . It can dynamically generate shaders at runtime and apply pixel shaders to the entire scene. The HLSL code is stored in .fx files in the Shader subdirectory of the Engine's source directory. They are compiled to .fxo files via a post-build script. Each HLSL file usually has a corresponding C# class in the OmegaEngine.Graphics.Shaders namespace.","title":"Overview"},{"location":"shaders/semantics/","text":"The DirectX Standard Annotations and Semantics (DXSAS) provide a way to add metadata to HLSL code that automates the integration between shader code and the engine. By specifying things such as value bindings for transform matrices shaders can more easily be exchanged between tools such as FX Composer and different graphics engines. The engine supports a subset of DXSAS 0.8.","title":"Semantics"}]}